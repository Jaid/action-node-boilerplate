{"version":3,"file":"789.js","mappings":"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","sources":["webpack://action-uptodater/./src/Rule.js","webpack://action-uptodater/./src/Tester.js","webpack://action-uptodater/./src/lib/consoleIcons.js","webpack://action-uptodater/./src/rules/webpackConfigJaid/index.js","webpack://action-uptodater/./src/testers/FileHasContent.js","webpack://action-uptodater/./src/testers/FileShouldNotExist.js","webpack://action-uptodater/./src/testers/ScriptExact.js"],"sourcesContent":["\nimport fsp from \"@absolunet/fsp\"\nimport ensureArray from \"ensure-array\"\n\nimport icons from \"./lib/consoleIcons.js\"\nimport hasContent, {isEmpty} from \"./lib/esm/has-content.js\"\n\nexport default class {\n\n  /**\n   * @type {import(\"src/Tester\").default[]}\n   */\n  testers = []\n\n  /**\n   * @type {string}\n   */\n  id = null\n\n  /**\n   * @type {string}\n   */\n  title = null\n\n  /**\n   * @type {number}\n   */\n  passedTests = 0\n\n  /**\n   * @type {number}\n   */\n  failedTests = 0\n\n  /**\n   * @type {string}\n   */\n  consoleIcon = icons.pass\n\n  /**\n   * @type {Object}\n   */\n  pkg = null\n\n  incrementPassedTests() {\n    this.passedTests++\n  }\n\n  incrementFailedTests() {\n    this.consoleIcon = icons.fail\n    this.failedTests++\n  }\n\n  getTitle() {\n    if (hasContent(this.title)) {\n      return this.title\n    }\n    return this.id\n  }\n\n  isRelevantToRepo(projectInfo) {\n    return true\n  }\n\n  hasTesters() {\n    return hasContent(this.testers)\n  }\n\n  /**\n   * @param {string} dependency\n   * @param {string|string[]} dependencyField\n   * @return {boolean}\n   */\n  hasDependency(dependency, dependencyField) {\n    const dependencyFields = dependencyField ? ensureArray(dependencyField) : [\n      \"dependencies\",\n      \"devDependencies\",\n      \"optionalDependencies\",\n      \"peerDependencies\",\n      \"bundleDependencies\",\n      \"bundledDependencies\",\n    ]\n    if (isEmpty(this.pkg)) {\n      return false\n    }\n    for (const key of dependencyFields) {\n      if (this.pkg[key]?.[dependency]) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * @param {string} dependency\n   * @return {boolean}\n   */\n  hasProductionDependency(dependency) {\n    return this.hasDependency(dependency, \"dependencies\")\n  }\n\n  /**\n   * @param {string} dependency\n   * @return {boolean}\n   */\n  hasDevelopmentDependency(dependency) {\n    return this.hasDependency(dependency, \"devDependencies\")\n  }\n\n  /**\n   * @param {string} file\n   * @return {Promise<boolean>}\n   */\n  async fileExists(file) {\n    const exists = await fsp.pathExists(file)\n    return exists\n  }\n\n  /**\n   * @param {import(\"src/Tester\").default} tester\n   */\n  addTester(tester) {\n    tester.rule = this\n    this.testers.push(tester)\n  }\n\n}","import {isFunction, isString} from \"lodash\"\nimport stripAnsi from \"strip-ansi\"\n\nimport Fix from \"./Fix.js\"\nimport icons from \"./lib/consoleIcons.js\"\nimport hasContent from \"./lib/esm/has-content.js\"\n\nexport default class {\n\n  /**\n   * @type {string}\n   */\n  title = \"Tester\"\n\n  /**\n   * @type {boolean}\n   */\n  passed = false\n\n  /**\n   * @type {import(\"src/Rule\").default}\n   */\n  rule = null\n\n  /**\n   * @type {string}\n   */\n  consoleIcon = icons.fail\n\n  /**\n   * @type {import(\"src/Fix\").default[]}\n   */\n  fixes = []\n\n  /**\n   * @type {import(\"src/Fix\").default[]}\n   */\n  appliedFixes = []\n\n  /**\n   * @type {string[]}\n   */\n  logMessages = []\n\n  /**\n   * @type {Function}\n   * This should be overriden\n   */\n  async test() {\n    return true\n  }\n\n  setTitle(ansiTitle) {\n    this.ansiTitle = ansiTitle\n    this.title = stripAnsi(ansiTitle)\n  }\n\n  setFunction(testFunction) {\n    this.test = testFunction\n  }\n\n  hasFix() {\n    return hasContent(this.fixes)\n  }\n\n  log(line) {\n    this.logMessages.push(line)\n  }\n\n  /**\n   * @param {import(\"./index\").ProjectInfo} projectInfo\n   * @return {Promise<boolean>}\n   */\n  async run(projectInfo) {\n    const result = await this.test(projectInfo)\n    if (result !== true) {\n      this.log(isString(result) ? result : \"Failed\")\n      if (projectInfo.shouldFix) {\n        if (isFunction(this.collectFixes)) {\n          this.collectFixes()\n        }\n        if (hasContent(this.fixes)) {\n          for (const fix of this.fixes) {\n            await fix.apply()\n            this.appliedFixes.push(fix)\n          }\n          const newResult = await this.test(projectInfo)\n          if (newResult === true) {\n            this.log(\"Fixed successfully\")\n            this.consoleIcon = icons.fix\n            this.rule.incrementPassedTests()\n            return true\n          } else {\n            this.consoleIcon = icons.fixFailed\n            this.log(\"Tried to apply a fix, but the test still failed on second run\")\n            if (isString(newResult)) {\n              this.log(newResult)\n            }\n          }\n        }\n      }\n      this.rule.incrementFailedTests()\n      return false\n    }\n    this.passed = true\n    this.consoleIcon = icons.pass\n    this.rule.incrementPassedTests()\n    this.log(\"Passed! <3\")\n    return true\n  }\n\n  addFix(fileName, content) {\n    const fix = new Fix(fileName, content)\n    fix.tester = this\n    this.fixes.push(fix)\n  }\n\n}","import figures from \"figures\"\n\nimport chalk from \"./chalk.js\"\n\nexport default {\n  pass: chalk.green(figures.tick),\n  fail: chalk.red(figures.cross),\n  fix: \"ðŸ”§\",\n  fixFailed: \"ðŸ’£\",\n}","import FileShouldNotExist from \"../../testers/FileShouldNotExist.js\"\nimport Rule from \"../../Rule.js\"\nimport FileHasContent from \"../../testers/FileHasContent.js\"\nimport ScriptExact from \"../../testers/ScriptExact.js\"\n\nexport default new class extends Rule {\n\n  title = \"Depends on webpack-config-jaid\"\n\n  /**\n   * @return {Promise<boolean>}\n   */\n  async isRelevantToRepo() {\n    return this.hasDevelopmentDependency(\"webpack-config-jaid\")\n  }\n\n  init() {\n    this.addTester(new FileHasContent(\"webpack.config.js\"))\n    this.addTester(new FileShouldNotExist(\"webpack.config.babel.js\"))\n    this.addTester(new ScriptExact(\"prepareActionJest\", \"npm run build:prod\"))\n  }\n\n}","import path from \"node:path\"\n\nimport fsp from \"@absolunet/fsp\"\n\nimport chalk from \"../lib/chalk.js\"\nimport Tester from \"../Tester.js\"\n\nexport default class extends Tester {\n\n  /**\n   * @type {string}\n   */\n  file = null\n\n  constructor(file) {\n    super()\n    this.file = path.resolve(file)\n    this.shortFile = file\n    this.setTitle(`${chalk.yellow(this.shortFile)} should exist and have content`)\n  }\n\n  /**\n   * @param {import(\"src/index\").ProjectInfo} projectInfo\n   * @return {Promise<Pick<boolean, string>>}\n   */\n  async test() {\n    const exists = await fsp.pathExists(this.file)\n    if (!exists) {\n      return `${this.shortFile} does not exist`\n    }\n    const stat = await fsp.stat(this.file)\n    const bytes = stat.size\n    if (!bytes) {\n      return `${this.shortFile} does exist, but is empty`\n    }\n    return true\n  }\n\n}","import path from \"node:path\"\n\nimport fsp from \"@absolunet/fsp\"\n\nimport chalk from \"../lib/chalk.js\"\nimport Tester from \"../Tester.js\"\n\nexport default class extends Tester {\n\n  /**\n   * @type {string}\n   */\n  file = null\n\n  constructor(file) {\n    super()\n    this.file = path.resolve(file)\n    this.shortFile = file\n    this.setTitle(`${chalk.yellow(this.shortFile)} should not exist`)\n  }\n\n  /**\n   * @param {import(\"src/index\").ProjectInfo} projectInfo\n   * @return {Promise<Pick<boolean, string>>}\n   */\n  async test() {\n    const exists = await fsp.pathExists(this.file)\n    if (exists) {\n      return `${this.shortFile} does exist`\n    }\n    return true\n  }\n\n  collectFixes() {\n    this.addFix(this.shortFile, false)\n  }\n\n\n}","import json5 from \"json5\"\nimport {isEqual} from \"lodash\"\n\nimport chalk from \"../lib/chalk.js\"\nimport {isEmpty} from \"../lib/esm/has-content.js\"\nimport getPkg from \"../lib/getPkg.js\"\nimport Tester from \"../Tester.js\"\n\nexport default class extends Tester {\n\n  /**\n   * @type {string}\n   */\n  scriptName = null\n\n  /**\n   * @type {string}\n   */\n  expectedValue = null\n\n  /**\n   * @type {Object}\n   */\n  pkg = null\n\n  constructor(scriptName, value) {\n    super()\n    this.scriptName = scriptName\n    this.expectedValue = value\n    this.setTitle(`${chalk.yellow(`package.json[${scriptName}]`)} should be ${chalk.blue(json5.stringify(value))}`)\n  }\n\n  /**\n   * @return {Promise<Pick<boolean, string>>}\n   */\n  async test() {\n    this.pkg = await getPkg()\n    if (this.pkg === null) {\n      return \"package.json does not exist\"\n    }\n    if (isEmpty(this.pkg)) {\n      return \"package.json has no content\"\n    }\n    if (isEmpty(this.pkg.scripts)) {\n      return \"package.json[scripts] has no content\"\n    }\n    const actualValue = this.pkg.scripts[this.scriptName]\n    if (actualValue === undefined) {\n      return `package.json[scripts] has no key ${this.scriptName}`\n    }\n    const equals = isEqual(this.expectedValue, actualValue)\n    if (!equals) {\n      return `Actual value of pkg[scripts][${this.scriptName}] is ${json5.stringify(actualValue)}`\n    }\n    return true\n  }\n\n  collectFixes() {\n    if (this.pkg === null) {\n      return\n    }\n    const pkgCopy = JSON.parse(JSON.stringify(this.pkg))\n    if (!pkgCopy.scripts) {\n      pkgCopy.scripts = {}\n    }\n    pkgCopy.scripts[this.scriptName] = this.expectedValue\n    this.addFix(\"package.json\", JSON.stringify(pkgCopy, null, 2))\n  }\n\n}"],"names":["testers","id","title","passedTests","failedTests","consoleIcon","icons","pkg","incrementPassedTests","this","incrementFailedTests","getTitle","hasContent","isRelevantToRepo","hasTesters","hasDependency","dependency","dependencyField","dependencyFields","ensureArray","isEmpty","key","hasProductionDependency","hasDevelopmentDependency","file","fsp","addTester","tester","rule","push","passed","fixes","appliedFixes","logMessages","setTitle","ansiTitle","stripAnsi","setFunction","testFunction","test","hasFix","log","line","projectInfo","result","isString","shouldFix","isFunction","collectFixes","fix","apply","newResult","addFix","fileName","content","Fix","pass","chalk","figures","fail","fixFailed","Rule","init","FileHasContent","FileShouldNotExist","ScriptExact","Tester","constructor","super","path","shortFile","size","scriptName","expectedValue","value","json5","getPkg","scripts","actualValue","isEqual","pkgCopy","JSON","parse","stringify"],"sourceRoot":""}