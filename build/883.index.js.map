{"version":3,"file":"883.index.js","mappings":"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","sources":["webpack://action-uptodater/./src/Rule.js","webpack://action-uptodater/./src/Tester.js","webpack://action-uptodater/./src/lib/consoleIcons.js","webpack://action-uptodater/./src/testers/FolderExists.js","webpack://action-uptodater/./src/rules/jaidCore/index.js","webpack://action-uptodater/./src/rules/jaidCore/srcIndex.js","webpack://action-uptodater/./src/lib/esm/read-file-string.js","webpack://action-uptodater/./src/lib/getMd5OfString.js","webpack://action-uptodater/./src/testers/FileExact.js","webpack://action-uptodater/./src/testers/FileHasContent.js"],"sourcesContent":["\nimport fsp from \"@absolunet/fsp\"\nimport ensureArray from \"ensure-array\"\n\nimport icons from \"./lib/consoleIcons.js\"\nimport hasContent, {isEmpty} from \"./lib/esm/has-content.js\"\n\nexport default class {\n\n  /**\n   * @type {import(\"src/Tester\").default[]}\n   */\n  testers = []\n\n  /**\n   * @type {string}\n   */\n  id = null\n\n  /**\n   * @type {string}\n   */\n  title = null\n\n  /**\n   * @type {number}\n   */\n  passedTests = 0\n\n  /**\n   * @type {number}\n   */\n  failedTests = 0\n\n  /**\n   * @type {string}\n   */\n  consoleIcon = icons.pass\n\n  /**\n   * @type {Object}\n   */\n  pkg = null\n\n  incrementPassedTests() {\n    this.passedTests++\n  }\n\n  incrementFailedTests() {\n    this.consoleIcon = icons.fail\n    this.failedTests++\n  }\n\n  getTitle() {\n    if (hasContent(this.title)) {\n      return this.title\n    }\n    return this.id\n  }\n\n  isRelevantToRepo(projectInfo) {\n    return true\n  }\n\n  hasTesters() {\n    return hasContent(this.testers)\n  }\n\n  /**\n   * @param {string} dependency\n   * @param {string|string[]} dependencyField\n   * @return {boolean}\n   */\n  hasDependency(dependency, dependencyField) {\n    const dependencyFields = dependencyField ? ensureArray(dependencyField) : [\n      \"dependencies\",\n      \"devDependencies\",\n      \"optionalDependencies\",\n      \"peerDependencies\",\n      \"bundleDependencies\",\n      \"bundledDependencies\",\n    ]\n    if (isEmpty(this.pkg)) {\n      return false\n    }\n    for (const key of dependencyFields) {\n      if (this.pkg[key]?.[dependency]) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * @param {string} dependency\n   * @return {boolean}\n   */\n  hasProductionDependency(dependency) {\n    return this.hasDependency(dependency, \"dependencies\")\n  }\n\n  /**\n   * @param {string} dependency\n   * @return {boolean}\n   */\n  hasDevelopmentDependency(dependency) {\n    return this.hasDependency(dependency, \"devDependencies\")\n  }\n\n  /**\n   * @param {string} file\n   * @return {Promise<boolean>}\n   */\n  async fileExists(file) {\n    const exists = await fsp.pathExists(file)\n    return exists\n  }\n\n  /**\n   * @param {import(\"src/Tester\").default} tester\n   */\n  addTester(tester) {\n    tester.rule = this\n    this.testers.push(tester)\n  }\n\n}","import {isFunction, isString} from \"lodash\"\nimport stripAnsi from \"strip-ansi\"\n\nimport Fix from \"./Fix.js\"\nimport icons from \"./lib/consoleIcons.js\"\nimport hasContent from \"./lib/esm/has-content.js\"\n\nexport default class {\n\n  /**\n   * @type {string}\n   */\n  title = \"Tester\"\n\n  /**\n   * @type {boolean}\n   */\n  passed = false\n\n  /**\n   * @type {import(\"src/Rule\").default}\n   */\n  rule = null\n\n  /**\n   * @type {string}\n   */\n  consoleIcon = icons.fail\n\n  /**\n   * @type {import(\"src/Fix\").default[]}\n   */\n  fixes = []\n\n  /**\n   * @type {import(\"src/Fix\").default[]}\n   */\n  appliedFixes = []\n\n  /**\n   * @type {string[]}\n   */\n  logMessages = []\n\n  /**\n   * @type {Function}\n   * This should be overriden\n   */\n  async test() {\n    return true\n  }\n\n  setTitle(ansiTitle) {\n    this.ansiTitle = ansiTitle\n    this.title = stripAnsi(ansiTitle)\n  }\n\n  setFunction(testFunction) {\n    this.test = testFunction\n  }\n\n  hasFix() {\n    return hasContent(this.fixes)\n  }\n\n  log(line) {\n    this.logMessages.push(line)\n  }\n\n  /**\n   * @param {import(\"./index\").ProjectInfo} projectInfo\n   * @return {Promise<boolean>}\n   */\n  async run(projectInfo) {\n    const result = await this.test(projectInfo)\n    if (result !== true) {\n      this.log(isString(result) ? result : \"Failed\")\n      if (projectInfo.shouldFix) {\n        if (isFunction(this.collectFixes)) {\n          this.collectFixes()\n        }\n        if (hasContent(this.fixes)) {\n          for (const fix of this.fixes) {\n            await fix.apply()\n            this.appliedFixes.push(fix)\n          }\n          const newResult = await this.test(projectInfo)\n          if (newResult === true) {\n            this.log(\"Fixed successfully\")\n            this.consoleIcon = icons.fix\n            this.rule.incrementPassedTests()\n            return true\n          } else {\n            this.consoleIcon = icons.fixFailed\n            this.log(\"Tried to apply a fix, but the test still failed on second run\")\n            if (isString(newResult)) {\n              this.log(newResult)\n            }\n          }\n        }\n      }\n      this.rule.incrementFailedTests()\n      return false\n    }\n    this.passed = true\n    this.consoleIcon = icons.pass\n    this.rule.incrementPassedTests()\n    this.log(\"Passed! <3\")\n    return true\n  }\n\n  addFix(fileName, content) {\n    const fix = new Fix(fileName, content)\n    fix.tester = this\n    this.fixes.push(fix)\n  }\n\n}","import figures from \"figures\"\n\nimport chalk from \"./chalk.js\"\n\nexport default {\n  pass: chalk.green(figures.tick),\n  fail: chalk.red(figures.cross),\n  fix: \"ðŸ”§\",\n  fixFailed: \"ðŸ’£\",\n}","import path from \"node:path\"\n\nimport fsp from \"@absolunet/fsp\"\n\nimport chalk from \"../lib/chalk.js\"\nimport Tester from \"../Tester.js\"\n\nexport default class extends Tester {\n\n  /**\n   * @type {string}\n   */\n  file = null\n\n  constructor(file) {\n    super()\n    this.file = path.resolve(file)\n    this.shortFile = file\n    this.setTitle(`Directory ${chalk.yellow(this.shortFile)} should exist`)\n  }\n\n  /**\n   * @param {import(\"src/index\").ProjectInfo} projectInfo\n   * @return {Promise<Pick<boolean, string>>}\n   */\n  async test() {\n    const exists = await fsp.pathExists(this.file)\n    if (!exists) {\n      return `${this.shortFile} does not exist`\n    }\n    const stat = await fsp.stat(this.file)\n    if (!stat.isDirectory()) {\n      return `${this.shortFile} is not a directory`\n    }\n    return true\n  }\n\n}","import Rule from \"../../Rule.js\"\nimport FileExact from \"../../testers/FileExact.js\"\nimport FileHasContent from \"../../testers/FileHasContent.js\"\nimport FolderExists from \"../../testers/FolderExists.js\"\n\nimport indexText from \"!raw-loader!./srcIndex.js\"\n// import indexText from \"./srcIndex.js?raw\"\n\nexport default new class extends Rule {\n\n  title = \"Depends on jaid-core\"\n\n  /**\n   * @return {Promise<boolean>}\n   */\n  async isRelevantToRepo() {\n    return this.hasProductionDependency(\"jaid-core\") && this.hasProductionDependency(\"yargs\")\n  }\n\n  init() {\n    this.addTester(new FileExact(\"src/index.js\", indexText))\n    this.addTester(new FolderExists(\"src/plugins\"))\n    this.addTester(new FileHasContent(\"src/core.js\"))\n  }\n\n}","export default \"import yargs from \\\"yargs\\\"\\n\\nimport {hideBin} from \\\"../node_modules/yargs/helpers/helpers.mjs\\\" // HACK Switch to yargs' ESM resolve shortcut \\\"yargs/helpers\\\" some day, but not now, it's not well supported by ESLint and webpack\\nimport core from \\\"./core.js\\\"\\nimport readableMs from \\\"./lib/esm/readable-ms.js\\\"\\n\\n/**\\n * @param {*} message\\n * @param {string} [level=\\\"info\\\"]\\n */\\nconst log = (message, level = \\\"info\\\") => {\\n  if (core?.logger?.[level]) {\\n    core.logger[level](message)\\n  } else {\\n    console[level](message)\\n  }\\n}\\n\\nprocess.on(\\\"exit\\\", code => {\\n  log(`Exiting with code ${code} after ${readableMs(Date.now() - core.startTime)}`)\\n})\\n\\n/**\\n * @return {Promise<void>}\\n */\\nconst job = async () => {\\n  const pluginsRequire = import.meta.webpackContext(\\\"./plugins\\\", {\\n    mode: \\\"lazy\\\",\\n    regExp: /^\\\\.\\\\/\\\\w+\\\\/index.js$/,\\n  })\\n  const loaders = pluginsRequire.keys().map(async value => {\\n    const plugin = await pluginsRequire(value)\\n    return [\\n      value.match(/[/\\\\\\\\](.+?)[/\\\\\\\\]index\\\\.js$/)[1],\\n      plugin.default,\\n    ]\\n  })\\n  const entries = await Promise.all(loaders)\\n  const plugins = Object.fromEntries(entries)\\n  await core.init(plugins)\\n}\\n\\n/**\\n * @type {import(\\\"yargs\\\").CommandBuilder}\\n */\\nconst builder = {\\n}\\n\\ntry {\\n  await yargs(hideBin(process.argv))\\n    .scriptName(process.env.REPLACE_PKG_NAME)\\n    .version(process.env.REPLACE_PKG_VERSION)\\n    .command(\\\"$0\\\", process.env.REPLACE_PKG_DESCRIPTION, builder, job)\\n    .parse()\\n} catch (error) {\\n  log(\\\"Unhandled error\\\", \\\"error\\\")\\n  log(error, \\\"error\\\")\\n}\";","import commonJsModule from \"read-file-string\"\n\nexport default commonJsModule.default","import crypto from \"node:crypto\"\n\nexport default input => {\n  return crypto.createHash(\"md5\").update(input).digest(\"hex\")\n}","import crypto from \"node:crypto\"\nimport path from \"node:path\"\n\nimport fsp from \"@absolunet/fsp\"\n\nimport chalk from \"../lib/chalk.js\"\nimport readFileString from \"../lib/esm/read-file-string.js\"\nimport getMd5OfString from \"../lib/getMd5OfString.js\"\nimport Tester from \"../Tester.js\"\n\nexport default class extends Tester {\n\n  /**\n   * @type {string}\n   */\n  expectedHash = null\n\n  /**\n   * @type {string}\n   */\n  file = null\n\n  constructor(file, expectedContent) {\n    super()\n    this.expectedContent = expectedContent\n    this.expectedHash = getMd5OfString(expectedContent)\n    this.file = path.resolve(file)\n    this.shortFile = file\n    this.setTitle(`${chalk.yellow(this.shortFile)} should have md5 ${chalk.blue(this.expectedHash)}`)\n  }\n\n  /**\n   * @param {import(\"src/index\").ProjectInfo} projectInfo\n   * @return {Promise<Pick<boolean, string>>}\n   */\n  async test() {\n    const fileContent = await readFileString(this.file)\n    if (!fileContent) {\n      return `${this.shortFile} does not exist`\n    }\n    const actualHash = getMd5OfString(fileContent)\n    if (actualHash === this.expectedHash) {\n      return true\n    }\n    return `They are not equal, got hash ${actualHash} from file`\n  }\n\n  collectFixes() {\n    this.addFix(this.shortFile, this.expectedContent)\n  }\n\n}","import path from \"node:path\"\n\nimport fsp from \"@absolunet/fsp\"\n\nimport chalk from \"../lib/chalk.js\"\nimport Tester from \"../Tester.js\"\n\nexport default class extends Tester {\n\n  /**\n   * @type {string}\n   */\n  file = null\n\n  constructor(file) {\n    super()\n    this.file = path.resolve(file)\n    this.shortFile = file\n    this.setTitle(`${chalk.yellow(this.shortFile)} should exist and have content`)\n  }\n\n  /**\n   * @param {import(\"src/index\").ProjectInfo} projectInfo\n   * @return {Promise<Pick<boolean, string>>}\n   */\n  async test() {\n    const exists = await fsp.pathExists(this.file)\n    if (!exists) {\n      return `${this.shortFile} does not exist`\n    }\n    const stat = await fsp.stat(this.file)\n    const bytes = stat.size\n    if (!bytes) {\n      return `${this.shortFile} does exist, but is empty`\n    }\n    return true\n  }\n\n}"],"names":["testers","id","title","passedTests","failedTests","consoleIcon","icons","pkg","incrementPassedTests","this","incrementFailedTests","getTitle","hasContent","isRelevantToRepo","hasTesters","hasDependency","dependency","dependencyField","dependencyFields","ensureArray","isEmpty","key","hasProductionDependency","hasDevelopmentDependency","file","fsp","addTester","tester","rule","push","passed","fixes","appliedFixes","logMessages","setTitle","ansiTitle","stripAnsi","setFunction","testFunction","test","hasFix","log","line","projectInfo","result","isString","shouldFix","isFunction","collectFixes","fix","apply","newResult","addFix","fileName","content","Fix","pass","chalk","figures","fail","fixFailed","Tester","constructor","super","path","shortFile","pathExists","stat","isDirectory","Rule","init","FileExact","FolderExists","FileHasContent","input","crypto","update","digest","expectedHash","expectedContent","getMd5OfString","fileContent","readFileString","actualHash","size"],"sourceRoot":""}