{"version":3,"file":"921.js","mappings":";;;;;;6IAOA,cAKEA,QAAU,GAKVC,GAAK,KAKLC,MAAQ,KAKRC,YAAc,EAKdC,YAAc,EAKdC,YAAcC,EAAAA,EAAAA,KAKdC,IAAM,KAENC,uBACEC,KAAKN,cAGPO,uBACED,KAAKJ,YAAcC,EAAAA,EAAAA,KACnBG,KAAKL,cAGPO,WAAY,OACNC,EAAAA,EAAAA,GAAWH,KAAKP,OACXO,KAAKP,MAEPO,KAAKR,GAGdY,mBACE,OAAM,EAGRC,aACE,OAAOF,EAAAA,EAAAA,GAAWH,KAAKT,SAQzBe,cAAcC,EAAYC,GACxB,MAAMC,EAAmBD,EAAkBE,EAAYF,GAAmB,CACxE,eACA,kBACA,uBACA,mBACA,qBACA,uBAEF,IAAIG,EAAAA,EAAAA,GAAQX,KAAKF,KACf,OAAM,EAER,IAAK,MAAMc,KAAOH,EAAkB,CAAC,IAAD,EAClC,aAAIT,KAAKF,IAAIc,UAAb,OAAI,EAAgBL,GAClB,OAAM,EAGV,OAAM,EAORM,wBAAwBN,GACtB,OAAOP,KAAKM,cAAcC,EAAY,gBAOxCO,yBAAyBP,GACvB,OAAOP,KAAKM,cAAcC,EAAY,mBAOxB,iBAACQ,GAEf,aADqBC,EAAAA,WAAeD,GAOtCE,UAAUC,GACRA,EAAOC,KAAOnB,KACdA,KAAKT,QAAQ6B,KAAKF,M,sFCpHtB,cAKEzB,MAAQ,SAKR4B,QAAM,EAKNF,KAAO,KAKPvB,YAAcC,EAAAA,EAAAA,KAKdyB,MAAQ,GAKRC,aAAe,GAKfC,YAAc,GAMJ,aACR,OAAM,EAGRC,SAASC,GACP1B,KAAK0B,UAAYA,EACjB1B,KAAKP,OAAQkC,EAAAA,EAAAA,GAAUD,GAGzBE,YAAYC,GACV7B,KAAK8B,KAAOD,EAGdE,SACE,OAAO5B,EAAAA,EAAAA,GAAWH,KAAKsB,OAGzBU,IAAIC,GACFjC,KAAKwB,YAAYJ,KAAKa,GAOf,UAACC,GACR,MAAMC,QAAenC,KAAK8B,KAAKI,GAC/B,IAAI,IAAAC,EAAiB,CAEnB,GADAnC,KAAKgC,KAAII,EAAAA,EAAAA,UAASD,GAAUA,EAAS,UACjCD,EAAYG,aACVC,EAAAA,EAAAA,YAAWtC,KAAKuC,eAClBvC,KAAKuC,gBAEHpC,EAAAA,EAAAA,GAAWH,KAAKsB,QAAQ,CAC1B,IAAK,MAAMkB,KAAOxC,KAAKsB,YACfkB,EAAIC,QACVzC,KAAKuB,aAAaH,KAAKoB,GAEzB,MAAME,QAAkB1C,KAAK8B,KAAKI,GAClC,IAAI,IAAAQ,EAIF,OAHA1C,KAAKgC,IAAI,sBACThC,KAAKJ,YAAcC,EAAAA,EAAAA,IACnBG,KAAKmB,KAAKpB,wBACV,EAEAC,KAAKJ,YAAcC,EAAAA,EAAAA,UACnBG,KAAKgC,IAAI,kEACLI,EAAAA,EAAAA,UAASM,IACX1C,KAAKgC,IAAIU,GAMjB,OADA1C,KAAKmB,KAAKlB,wBACV,EAMF,OAJAD,KAAKqB,QAAL,EACArB,KAAKJ,YAAcC,EAAAA,EAAAA,KACnBG,KAAKmB,KAAKpB,uBACVC,KAAKgC,IAAI,eACT,EAGFW,OAAOC,EAAUC,GACf,MAAML,EAAM,IAAIM,EAAAA,EAAIF,EAAUC,GAC9BL,EAAItB,OAASlB,KACbA,KAAKsB,MAAMF,KAAKoB,M,wDC9GpB,SACEO,KAAMC,EAAAA,EAAAA,MAAYC,EAAAA,EAAAA,MAClBC,KAAMF,EAAAA,EAAAA,IAAUC,EAAAA,EAAAA,OAChBT,IAAK,KACLW,UAAW,O,mGCDb,sBAA6BC,EAAAA,EAK3BrC,KAAO,KAEPsC,YAAYtC,GACVuC,QACAtD,KAAKe,KAAOwC,EAAAA,QAAaxC,GACzBf,KAAKwD,UAAYzC,EACjBf,KAAKyB,SAAU,GAAEuB,EAAAA,EAAAA,OAAahD,KAAKwD,2BAO3B,aAAG,cACUxC,EAAIyC,WAAWzD,KAAKe,OAE/B,GAAEf,KAAKwD,6B,wBCvBrB,YAAmB,cAAcE,EAAAA,EAE/BjE,MAAQ,OAERkE,OACE3D,KAAKiB,UAAU,IAAI2C,EAAAA,EAAc,SAAU,wDAC3C5D,KAAKiB,UAAU,IAAI4C,EAAAA,EAAmB,aACtC7D,KAAKiB,UAAU,IAAI6C,EAAW,kBAC9B9D,KAAKiB,UAAU,IAAI4C,EAAAA,EAAmB,kBACtC7D,KAAKiB,UAAU,IAAI4C,EAAAA,EAAmB,yB,4ECP1C,sBAA6BT,EAAAA,EAK3BrC,KAAO,KAEPsC,YAAYtC,GACVuC,QACAtD,KAAKe,KAAOwC,EAAAA,QAAaxC,GACzBf,KAAKwD,UAAYzC,EACjBf,KAAKyB,SAAU,GAAEuB,EAAAA,EAAAA,OAAahD,KAAKwD,+BAO3B,aAAG,aACUxC,EAAAA,WAAehB,KAAKe,OAE/B,GAAEf,KAAKwD,uBAKnBjB,eACEvC,KAAK2C,OAAO3C,KAAKwD,WAAjB,M,kEChCJ,Q,QAAA,Q,kCCOA,sBAA6BJ,EAAAA,EAK3BW,MAAQ,KAKRC,cAAgB,KAKhBlE,IAAM,KAENuD,YAAYU,EAAOE,GACjBX,QACAtD,KAAK+D,MAAQA,EACb/D,KAAKgE,cAAgBC,EACrBjE,KAAKyB,SAAU,GAAEuB,EAAAA,EAAAA,OAAc,gBAAee,mBAAuBf,EAAAA,EAAAA,KAAWkB,EAAWC,EAAAA,UAAgBF,GAAQ,QAM3G,aAER,GADAjE,KAAKF,UAAYsE,EAAAA,EAAAA,KACA,OAAbpE,KAAKF,IACP,MAAO,8BAET,IAAIa,EAAAA,EAAAA,GAAQX,KAAKF,KACf,MAAO,8BAET,MAAMuE,EAAcrE,KAAKF,IAAIE,KAAK+D,OAClC,QAAI,IAAAM,EACF,MAAQ,2BAA0BrE,KAAK+D,QAV9B,SAYIO,EAAAA,EAAAA,SAAQtE,KAAKgE,cAAeK,IAEjC,uBAAsBrE,KAAK+D,aAAaI,EAAAA,UAAgBE,KAKpE9B,eACE,GAAiB,OAAbvC,KAAKF,IAAT,CAGA,MAAMyE,EAAUC,KAAKC,MAAMD,KAAKE,UAAU1E,KAAKF,MAC/CyE,EAAQvE,KAAK+D,OAAS/D,KAAKgE,cAC3BhE,KAAK2C,OAAO,eAAgB6B,KAAKE,UAAUH,EAAS,KAAM","sources":["webpack://action-uptodater/./src/Rule.js","webpack://action-uptodater/./src/Tester.js","webpack://action-uptodater/./src/lib/consoleIcons.js","webpack://action-uptodater/./src/testers/FileExists.js","webpack://action-uptodater/./src/rules/node/index.js","webpack://action-uptodater/./src/testers/FileShouldNotExist.js","webpack://action-uptodater/./src/lib/esm/crop-string.js","webpack://action-uptodater/./src/testers/PkgFieldExact.js"],"sourcesContent":["\nimport fsp from \"@absolunet/fsp\"\nimport ensureArray from \"ensure-array\"\n\nimport icons from \"./lib/consoleIcons.js\"\nimport hasContent, {isEmpty} from \"./lib/esm/has-content.js\"\n\nexport default class {\n\n  /**\n   * @type {import(\"src/Tester\").default[]}\n   */\n  testers = []\n\n  /**\n   * @type {string}\n   */\n  id = null\n\n  /**\n   * @type {string}\n   */\n  title = null\n\n  /**\n   * @type {number}\n   */\n  passedTests = 0\n\n  /**\n   * @type {number}\n   */\n  failedTests = 0\n\n  /**\n   * @type {string}\n   */\n  consoleIcon = icons.pass\n\n  /**\n   * @type {Object}\n   */\n  pkg = null\n\n  incrementPassedTests() {\n    this.passedTests++\n  }\n\n  incrementFailedTests() {\n    this.consoleIcon = icons.fail\n    this.failedTests++\n  }\n\n  getTitle() {\n    if (hasContent(this.title)) {\n      return this.title\n    }\n    return this.id\n  }\n\n  isRelevantToRepo(projectInfo) {\n    return true\n  }\n\n  hasTesters() {\n    return hasContent(this.testers)\n  }\n\n  /**\n   * @param {string} dependency\n   * @param {string|string[]} dependencyField\n   * @return {boolean}\n   */\n  hasDependency(dependency, dependencyField) {\n    const dependencyFields = dependencyField ? ensureArray(dependencyField) : [\n      \"dependencies\",\n      \"devDependencies\",\n      \"optionalDependencies\",\n      \"peerDependencies\",\n      \"bundleDependencies\",\n      \"bundledDependencies\",\n    ]\n    if (isEmpty(this.pkg)) {\n      return false\n    }\n    for (const key of dependencyFields) {\n      if (this.pkg[key]?.[dependency]) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * @param {string} dependency\n   * @return {boolean}\n   */\n  hasProductionDependency(dependency) {\n    return this.hasDependency(dependency, \"dependencies\")\n  }\n\n  /**\n   * @param {string} dependency\n   * @return {boolean}\n   */\n  hasDevelopmentDependency(dependency) {\n    return this.hasDependency(dependency, \"devDependencies\")\n  }\n\n  /**\n   * @param {string} file\n   * @return {Promise<boolean>}\n   */\n  async fileExists(file) {\n    const exists = await fsp.pathExists(file)\n    return exists\n  }\n\n  /**\n   * @param {import(\"src/Tester\").default} tester\n   */\n  addTester(tester) {\n    tester.rule = this\n    this.testers.push(tester)\n  }\n\n}","import {isFunction, isString} from \"lodash\"\nimport stripAnsi from \"strip-ansi\"\n\nimport Fix from \"./Fix.js\"\nimport icons from \"./lib/consoleIcons.js\"\nimport hasContent from \"./lib/esm/has-content.js\"\n\nexport default class {\n\n  /**\n   * @type {string}\n   */\n  title = \"Tester\"\n\n  /**\n   * @type {boolean}\n   */\n  passed = false\n\n  /**\n   * @type {import(\"src/Rule\").default}\n   */\n  rule = null\n\n  /**\n   * @type {string}\n   */\n  consoleIcon = icons.fail\n\n  /**\n   * @type {import(\"src/Fix\").default[]}\n   */\n  fixes = []\n\n  /**\n   * @type {import(\"src/Fix\").default[]}\n   */\n  appliedFixes = []\n\n  /**\n   * @type {string[]}\n   */\n  logMessages = []\n\n  /**\n   * @type {Function}\n   * This should be overriden\n   */\n  async test() {\n    return true\n  }\n\n  setTitle(ansiTitle) {\n    this.ansiTitle = ansiTitle\n    this.title = stripAnsi(ansiTitle)\n  }\n\n  setFunction(testFunction) {\n    this.test = testFunction\n  }\n\n  hasFix() {\n    return hasContent(this.fixes)\n  }\n\n  log(line) {\n    this.logMessages.push(line)\n  }\n\n  /**\n   * @param {import(\"./index\").ProjectInfo} projectInfo\n   * @return {Promise<boolean>}\n   */\n  async run(projectInfo) {\n    const result = await this.test(projectInfo)\n    if (result !== true) {\n      this.log(isString(result) ? result : \"Failed\")\n      if (projectInfo.shouldFix) {\n        if (isFunction(this.collectFixes)) {\n          this.collectFixes()\n        }\n        if (hasContent(this.fixes)) {\n          for (const fix of this.fixes) {\n            await fix.apply()\n            this.appliedFixes.push(fix)\n          }\n          const newResult = await this.test(projectInfo)\n          if (newResult === true) {\n            this.log(\"Fixed successfully\")\n            this.consoleIcon = icons.fix\n            this.rule.incrementPassedTests()\n            return true\n          } else {\n            this.consoleIcon = icons.fixFailed\n            this.log(\"Tried to apply a fix, but the test still failed on second run\")\n            if (isString(newResult)) {\n              this.log(newResult)\n            }\n          }\n        }\n      }\n      this.rule.incrementFailedTests()\n      return false\n    }\n    this.passed = true\n    this.consoleIcon = icons.pass\n    this.rule.incrementPassedTests()\n    this.log(\"Passed! <3\")\n    return true\n  }\n\n  addFix(fileName, content) {\n    const fix = new Fix(fileName, content)\n    fix.tester = this\n    this.fixes.push(fix)\n  }\n\n}","import figures from \"figures\"\n\nimport chalk from \"./chalk.js\"\n\nexport default {\n  pass: chalk.green(figures.tick),\n  fail: chalk.red(figures.cross),\n  fix: \"ðŸ”§\",\n  fixFailed: \"ðŸ’£\",\n}","import path from \"node:path\"\n\nimport fsp from \"@absolunet/fsp\"\n\nimport chalk from \"../lib/chalk.js\"\nimport Tester from \"../Tester.js\"\n\nexport default class extends Tester {\n\n  /**\n   * @type {string}\n   */\n  file = null\n\n  constructor(file) {\n    super()\n    this.file = path.resolve(file)\n    this.shortFile = file\n    this.setTitle(`${chalk.yellow(this.shortFile)} should exist`)\n  }\n\n  /**\n   * @param {import(\"src/index\").ProjectInfo} projectInfo\n   * @return {Promise<Pick<boolean, string>>}\n   */\n  async test() {\n    const exists = await fsp.pathExists(this.file)\n    if (!exists) {\n      return `${this.shortFile} does not exist`\n    }\n    return true\n  }\n\n}","import Rule from \"../../Rule.js\"\nimport FileExists from \"../../testers/FileExists.js\"\nimport FileShouldNotExist from \"../../testers/FileShouldNotExist.js\"\nimport PkgFieldExact from \"../../testers/PkgFieldExact.js\"\n\nexport default new class extends Rule {\n\n  title = \"Node\"\n\n  init() {\n    this.addTester(new PkgFieldExact(\"author\", \"Jaid <jaid.jsx@gmail.com> (https://github.com/Jaid)\"))\n    this.addTester(new FileShouldNotExist(\"index.js\"))\n    this.addTester(new FileExists(\"tsconfig.json\"))\n    this.addTester(new FileShouldNotExist(\"jsconfig.json\"))\n    this.addTester(new FileShouldNotExist(\"tsconfigBase.json\"))\n  }\n\n}","import path from \"node:path\"\n\nimport fsp from \"@absolunet/fsp\"\n\nimport chalk from \"../lib/chalk.js\"\nimport Tester from \"../Tester.js\"\n\nexport default class extends Tester {\n\n  /**\n   * @type {string}\n   */\n  file = null\n\n  constructor(file) {\n    super()\n    this.file = path.resolve(file)\n    this.shortFile = file\n    this.setTitle(`${chalk.yellow(this.shortFile)} should not exist`)\n  }\n\n  /**\n   * @param {import(\"src/index\").ProjectInfo} projectInfo\n   * @return {Promise<Pick<boolean, string>>}\n   */\n  async test() {\n    const exists = await fsp.pathExists(this.file)\n    if (exists) {\n      return `${this.shortFile} does exist`\n    }\n    return true\n  }\n\n  collectFixes() {\n    this.addFix(this.shortFile, false)\n  }\n\n\n}","import commonJsModule from \"crop-string\"\n\nexport default commonJsModule.default","import json5 from \"json5\"\nimport {isEqual} from \"lodash\"\n\nimport chalk from \"../lib/chalk.js\"\nimport cropString from \"../lib/esm/crop-string.js\"\nimport {isEmpty} from \"../lib/esm/has-content.js\"\nimport getPkg from \"../lib/getPkg.js\"\nimport Tester from \"../Tester.js\"\n\nexport default class extends Tester {\n\n  /**\n   * @type {string}\n   */\n  field = null\n\n  /**\n   * @type {string}\n   */\n  expectedValue = null\n\n  /**\n   * @type {Object}\n   */\n  pkg = null\n\n  constructor(field, value) {\n    super()\n    this.field = field\n    this.expectedValue = value\n    this.setTitle(`${chalk.yellow(`package.json[${field}]`)} should be ${chalk.blue(cropString(json5.stringify(value), 50))}`)\n  }\n\n  /**\n   * @return {Promise<boolean|string>}\n   */\n  async test() {\n    this.pkg = await getPkg()\n    if (this.pkg === null) {\n      return \"package.json does not exist\"\n    }\n    if (isEmpty(this.pkg)) {\n      return \"package.json has no content\"\n    }\n    const actualValue = this.pkg[this.field]\n    if (actualValue === undefined) {\n      return `package.json has no key ${this.field}`\n    }\n    const equals = isEqual(this.expectedValue, actualValue)\n    if (!equals) {\n      return `Actual value of pkg[${this.field}] is ${json5.stringify(actualValue)}`\n    }\n    return true\n  }\n\n  collectFixes() {\n    if (this.pkg === null) {\n      return\n    }\n    const pkgCopy = JSON.parse(JSON.stringify(this.pkg))\n    pkgCopy[this.field] = this.expectedValue\n    this.addFix(\"package.json\", JSON.stringify(pkgCopy, null, 2))\n  }\n\n}"],"names":["testers","id","title","passedTests","failedTests","consoleIcon","icons","pkg","incrementPassedTests","this","incrementFailedTests","getTitle","hasContent","isRelevantToRepo","hasTesters","hasDependency","dependency","dependencyField","dependencyFields","ensureArray","isEmpty","key","hasProductionDependency","hasDevelopmentDependency","file","fsp","addTester","tester","rule","push","passed","fixes","appliedFixes","logMessages","setTitle","ansiTitle","stripAnsi","setFunction","testFunction","test","hasFix","log","line","projectInfo","result","isString","shouldFix","isFunction","collectFixes","fix","apply","newResult","addFix","fileName","content","Fix","pass","chalk","figures","fail","fixFailed","Tester","constructor","super","path","shortFile","pathExists","Rule","init","PkgFieldExact","FileShouldNotExist","FileExists","field","expectedValue","value","cropString","json5","getPkg","actualValue","isEqual","pkgCopy","JSON","parse","stringify"],"sourceRoot":""}