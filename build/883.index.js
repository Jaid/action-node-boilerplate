/*!
*** action-uptodater 2.5.0
*** Copyright Â© 2022, Jaid <jaid.jsx@gmail.com> (https://github.com/Jaid)
*** @license MIT
*** See https://github.com/Jaid/action-node-boilerplate
!*/
export const id=883;export const ids=[883];export const modules={4757:(e,s,t)=>{t.d(s,{Z:()=>l});var i=t(8245),n=t(3079),r=t(8632),o=t(3885);const l=class{testers=[];id=null;title=null;passedTests=0;failedTests=0;consoleIcon=r.Z.pass;pkg=null;incrementPassedTests(){this.passedTests++}incrementFailedTests(){this.consoleIcon=r.Z.fail,this.failedTests++}getTitle(){return(0,o.Z)(this.title)?this.title:this.id}isRelevantToRepo(){return!0}hasTesters(){return(0,o.Z)(this.testers)}hasDependency(e,s){const t=s?n(s):["dependencies","devDependencies","optionalDependencies","peerDependencies","bundleDependencies","bundledDependencies"];if((0,o.x)(this.pkg))return!1;for(const s of t){var i;if(null!==(i=this.pkg[s])&&void 0!==i&&i[e])return!0}return!1}hasProductionDependency(e){return this.hasDependency(e,"dependencies")}hasDevelopmentDependency(e){return this.hasDependency(e,"devDependencies")}async fileExists(e){return await i.pathExists(e)}addTester(e){e.rule=this,this.testers.push(e)}}},8345:(e,s,t)=>{t.d(s,{Z:()=>a});var i=t(6486),n=t(5089),r=t(4592),o=t(8632),l=t(3885);const a=class{title="Tester";passed=!1;rule=null;consoleIcon=o.Z.fail;fixes=[];appliedFixes=[];logMessages=[];async test(){return!0}setTitle(e){this.ansiTitle=e,this.title=(0,n.Z)(e)}setFunction(e){this.test=e}hasFix(){return(0,l.Z)(this.fixes)}log(e){this.logMessages.push(e)}async run(e){const s=await this.test(e);if(!0!==s){if(this.log((0,i.isString)(s)?s:"Failed"),e.shouldFix&&((0,i.isFunction)(this.collectFixes)&&this.collectFixes(),(0,l.Z)(this.fixes))){for(const e of this.fixes)await e.apply(),this.appliedFixes.push(e);const s=await this.test(e);if(!0===s)return this.log("Fixed successfully"),this.consoleIcon=o.Z.fix,this.rule.incrementPassedTests(),!0;this.consoleIcon=o.Z.fixFailed,this.log("Tried to apply a fix, but the test still failed on second run"),(0,i.isString)(s)&&this.log(s)}return this.rule.incrementFailedTests(),!1}return this.passed=!0,this.consoleIcon=o.Z.pass,this.rule.incrementPassedTests(),this.log("Passed! <3"),!0}addFix(e,s){const t=new r.Z(e,s);t.tester=this,this.fixes.push(t)}}},8632:(e,s,t)=>{t.d(s,{Z:()=>r});var i=t(5264),n=t(4723);const r={pass:n.Z.green(i.ZP.tick),fail:n.Z.red(i.ZP.cross),fix:"ðŸ”§",fixFailed:"ðŸ’£"}},7883:(e,s,t)=>{t.r(s),t.d(s,{default:()=>h});var i=t(4757),n=t(8410),r=t(6380),o=t(9411),l=t(8245),a=t(4723),c=t(8345);const d=class extends c.Z{file=null;constructor(e){super(),this.file=o.resolve(e),this.shortFile=e,this.setTitle(`Directory ${a.Z.yellow(this.shortFile)} should exist`)}async test(){if(!await l.pathExists(this.file))return`${this.shortFile} does not exist`;return!!(await l.stat(this.file)).isDirectory()||`${this.shortFile} is not a directory`}},h=new class extends i.Z{title="Depends on jaid-core";async isRelevantToRepo(){return this.hasProductionDependency("jaid-core")&&this.hasProductionDependency("yargs")}init(){this.addTester(new n.Z("src/index.js",'import yargs from "yargs"\n\nimport {hideBin} from "../node_modules/yargs/helpers/helpers.mjs" // TODO Switch to yargs\' ESM resolve shortcut "yargs/helpers" some day, but not now, it\'s not well supported by ESLint and webpack\nimport core from "./core.js"\nimport readableMs from "./lib/esm/readable-ms.js"\n\n/**\n * @param {*} message\n * @param {string} [level="info"]\n */\nconst log = (message, level = "info") => {\n  if (core?.logger?.[level]) {\n    core.logger[level](message)\n  } else {\n    console[level](message)\n  }\n}\n\nprocess.on("exit", code => {\n  log(`Exiting with code ${code} after ${readableMs(Date.now() - core.startTime)}`)\n})\n\n/**\n * @return {Promise<void>}\n */\nconst job = async () => {\n  const pluginsRequire = import.meta.webpackContext("./plugins", {\n    mode: "lazy",\n    regExp: /^\\.\\/\\w+\\/index.js$/,\n  })\n  const loaders = pluginsRequire.keys().map(async value => {\n    const plugin = await pluginsRequire(value)\n    return [\n      value.match(/[/\\\\](.+?)[/\\\\]index\\.js$/)[1],\n      plugin.default,\n    ]\n  })\n  const entries = await Promise.all(loaders)\n  const plugins = Object.fromEntries(entries)\n  await core.init(plugins)\n}\n\n/**\n * @type {import("yargs").CommandBuilder}\n */\nconst builder = {\n}\n\ntry {\n  await yargs(hideBin(process.argv))\n    .scriptName(process.env.REPLACE_PKG_NAME)\n    .version(process.env.REPLACE_PKG_VERSION)\n    .command("$0", process.env.REPLACE_PKG_DESCRIPTION, builder, job)\n    .parse()\n} catch (error) {\n  log("Unhandled error", "error")\n  log(error, "error")\n}')),this.addTester(new d("src/plugins")),this.addTester(new r.Z("src/core.js"))}}},8410:(e,s,t)=>{t.d(s,{Z:()=>c});var i=t(6005),n=t(9411),r=(t(8245),t(4723));const o=t(7088).default,l=e=>i.createHash("md5").update(e).digest("hex");var a=t(8345);const c=class extends a.Z{expectedHash=null;file=null;constructor(e,s){super(),this.expectedContent=s,this.expectedHash=l(s),this.file=n.resolve(e),this.shortFile=e,this.setTitle(`${r.Z.yellow(this.shortFile)} should have md5 ${r.Z.blue(this.expectedHash)}`)}async test(){const e=await o(this.file);if(!e)return`${this.shortFile} does not exist`;const s=l(e);return!(s!==this.expectedHash)||`They are not equal, got hash ${s} from file`}collectFixes(){this.addFix(this.shortFile,this.expectedContent)}}},6380:(e,s,t)=>{t.d(s,{Z:()=>l});var i=t(9411),n=t(8245),r=t(4723),o=t(8345);const l=class extends o.Z{file=null;constructor(e){super(),this.file=i.resolve(e),this.shortFile=e,this.setTitle(`${r.Z.yellow(this.shortFile)} should exist and have content`)}async test(){if(!await n.pathExists(this.file))return`${this.shortFile} does not exist`;return!!(await n.stat(this.file)).size||`${this.shortFile} does exist, but is empty`}}}};
//# sourceMappingURL=883.index.js.map