/*!
*** action-uptodater 2.5.1
*** Copyright Â© 2022, Jaid <jaid.jsx@gmail.com> (https://github.com/Jaid)
*** @license MIT
*** See https://github.com/Jaid/action-node-boilerplate
!*/
export const id=646;export const ids=[646];export const modules={4757:(e,s,t)=>{t.d(s,{a:()=>o});var i=t(8245),n=t(3079),a=t(8632),l=t(3885);const o=class{testers=[];id=null;title=null;passedTests=0;failedTests=0;consoleIcon=a.a.pass;pkg=null;incrementPassedTests(){this.passedTests++}incrementFailedTests(){this.consoleIcon=a.a.fail,this.failedTests++}getTitle(){return(0,l.a)(this.title)?this.title:this.id}isRelevantToRepo(){return!0}hasTesters(){return(0,l.a)(this.testers)}hasDependency(e,s){const t=s?n(s):["dependencies","devDependencies","optionalDependencies","peerDependencies","bundleDependencies","bundledDependencies"];if((0,l.b)(this.pkg))return!1;for(const s of t){var i;if(null!==(i=this.pkg[s])&&void 0!==i&&i[e])return!0}return!1}hasProductionDependency(e){return this.hasDependency(e,"dependencies")}hasDevelopmentDependency(e){return this.hasDependency(e,"devDependencies")}async fileExists(e){return await i.pathExists(e)}addTester(e){e.rule=this,this.testers.push(e)}}},8345:(e,s,t)=>{t.d(s,{a:()=>r});var i=t(6486),n=t(5089),a=t(4592),l=t(8632),o=t(3885);const r=class{title="Tester";passed=!1;rule=null;consoleIcon=l.a.fail;fixes=[];appliedFixes=[];logMessages=[];async test(){return!0}setTitle(e){this.ansiTitle=e,this.title=(0,n.a)(e)}setFunction(e){this.test=e}hasFix(){return(0,o.a)(this.fixes)}log(e){this.logMessages.push(e)}async run(e){const s=await this.test(e);if(!0!==s){if(this.log((0,i.isString)(s)?s:"Failed"),e.shouldFix&&((0,i.isFunction)(this.collectFixes)&&this.collectFixes(),(0,o.a)(this.fixes))){for(const e of this.fixes)await e.apply(),this.appliedFixes.push(e);const s=await this.test(e);if(!0===s)return this.log("Fixed successfully"),this.consoleIcon=l.a.fix,this.rule.incrementPassedTests(),!0;this.consoleIcon=l.a.fixFailed,this.log("Tried to apply a fix, but the test still failed on second run"),(0,i.isString)(s)&&this.log(s)}return this.rule.incrementFailedTests(),!1}return this.passed=!0,this.consoleIcon=l.a.pass,this.rule.incrementPassedTests(),this.log("Passed! <3"),!0}addFix(e,s){const t=new a.a(e,s);t.tester=this,this.fixes.push(t)}}},8632:(e,s,t)=>{t.d(s,{a:()=>a});var i=t(5264),n=t(9486);const a={pass:n.a.green(i.a.tick),fail:n.a.red(i.a.cross),fix:"ðŸ”§",fixFailed:"ðŸ’£"}},1646:(e,s,t)=>{t.r(s),t.d(s,{default:()=>o});var i=t(8142),n=t(1680),a=t(4757),l=t(4868);const o=new class extends a.a{title="Node package that gets published publicly";async isRelevantToRepo(){const e=await(0,n.a)();return!!e&&!e.private&&!!e.name}init(){this.addTester(new l.a("name",i.context.repo.repo))}}},4868:(e,s,t)=>{t.d(s,{a:()=>d});var i=t(3169),n=t(6486),a=t(9486);const l=t(9426).default;var o=t(3885),r=t(1680),c=t(8345);const d=class extends c.a{field=null;expectedValue=null;pkg=null;constructor(e,s){super(),this.field=e,this.expectedValue=s,this.setTitle(`${a.a.yellow(`package.json[${e}]`)} should be ${a.a.blue(l(i.stringify(s),50))}`)}async test(){if(this.pkg=await(0,r.a)(),null===this.pkg)return"package.json does not exist";if((0,o.b)(this.pkg))return"package.json has no content";const e=this.pkg[this.field];if(void 0===e)return`package.json has no key ${this.field}`;return!!(0,n.isEqual)(this.expectedValue,e)||`Actual value of pkg[${this.field}] is ${i.stringify(e)}`}collectFixes(){if(null!==this.pkg){const e=JSON.parse(JSON.stringify(this.pkg));e[this.field]=this.expectedValue,this.addFix("package.json",JSON.stringify(e,null,2))}}}}};
//# sourceMappingURL=646.js.map